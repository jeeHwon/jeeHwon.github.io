---
title: Swift 생성자와 초기화 규칙
author: kenjee
date: 2025-03-01 12:00:00 +09:00
categories: [iOS]
tags: [Swift, Initializer]
---

# 들어가며

Swift에서 객체의 생성 과정은 코드의 안정성과 유지보수성에 중요한 역할을 한다.  
특히, **Swift에서는 클래스와 구조체의 동작 방식이 다르며, 생성자의 올바른 사용이 객체의 안정성을 보장하는 핵심 요소**가 된다.  
이번 글에서는 **지정 생성자, 편의 생성자, 생성자 상속과 재정의, 생성자 위임 규칙, 2단계 초기화 과정**을 알아본다.

---

## 1️⃣ 생성자란?

### 생성자의 역할

- 객체가 생성될 때 **모든 저장 속성을 초기화하는 함수**
- Swift에서는 **모든 저장 속성이 초기값을 가져야 하며, 직접 할당하거나 생성자를 통해 설정해야 함**
- **구조체**는 모든 저장 속성에 기본값이 없을 경우 **멤버와이즈 생성자가 자동 제공됨**
- **클래스**는 모든 저장 속성에 기본값이 있을 경우 **기본 생성자가 자동 제공됨**
- **저장 속성에 기본값이 없거나, 특정한 초기화가 필요할 경우 직접 생성자를 정의해야 함**

### 구조체 vs 클래스: 생성자 차이

- **구조체**: 멤버와이즈(memberwise) 생성자가 자동 제공됨
- **클래스**: 기본 생성자는 저장 속성에 기본값이 없을 경우 자동으로 제공되지 않으며, 직접 정의해야 함

```swift
struct Point {
    var x: Double
    var y: Double
}

let point = Point(x: 0.0, y: 0.0) // 멤버와이즈 생성자 자동 제공
```

```swift
class Person {
    var name: String
    var age: Int

    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}
```

---

## 2️⃣ 생성자의 종류

Swift의 생성자에는 **지정 생성자, 편의 생성자, 필수 생성자, 실패 가능 생성자** 등이 있다.  
이번 포스팅에서는 **지정 생성자와 편의 생성자**를 다룬다.

### 1. 지정 생성자(Designated Initializer)

- 객체의 모든 저장 속성을 초기화하는 **핵심 생성자**
- 클래스에서는 최소 하나 이상의 지정 생성자가 필요함

```swift
class Vehicle {
    var numberOfWheels: Int

    init(numberOfWheels: Int) {
        self.numberOfWheels = numberOfWheels
    }
}
```

### 2. 편의 생성자(Convenience Initializer)

- **지정 생성자를 보조하는 역할**. 이름 그대로 손쉽게 생성할 수 있도록 도와줌.
- 같은 클래스의 다른 생성자를 호출해야 하며, 최종적으로 지정 생성자로 이어져야 함

```swift
class Vehicle {
    var numberOfWheels: Int

    init(numberOfWheels: Int) {
        self.numberOfWheels = numberOfWheels
    }

    convenience init() {
        self.init(numberOfWheels: 4)
    }
}
```

---

## 3️⃣ 생성자 상속과 재정의

### 생성자의 상속 원칙

- **하위 클래스는 기본적으로 상위 클래스의 생성자를 자동으로 상속하지 않는다.**
- 이는 하위 클래스가 상위 클래스의 생성자를 그대로 상속하면, **올바르게 초기화되지 않을 가능성이 있기 때문**.
- 하지만 **안전한 경우?에 한해** 상위 클래스의 생성자가 자동으로 상속될 수 있다.

### 생성자 상속 시 구현 규칙

1. **상위 클래스의 지정 생성자(이름/파라미터)를 고려하여 재정의해야 한다.**
2. **하위 클래스는 상위 클래스의 지정 생성자를 동일한 이름으로 재정의할 수 있다.**
3. **하위 클래스에서 편의 생성자로 변환하여 구현할 수도 있다.**
4. **상위 클래스의 편의 생성자는 재정의할 필요가 없으며, 호출도 불가능하다.**

```swift
class Aclass {
    var x = 0
}

class Bclass: Aclass {
    var y: Int

    override init() { // 지정 생성자 재정의
        self.y = 0
        super.init()
    }
}
```

---

## 4️⃣ 생성자 위임 규칙(Initializer Delegation)

Swift에서는 생성자를 호출하는 방식에 대한 **두 가지 위임 규칙**이 있다.

### 1. 델리게이트 업(Delegate Up)

- **하위 클래스의 지정 생성자는 반드시 슈퍼클래스의 지정 생성자를 호출해야 한다.**
- 상속된 속성을 올바르게 초기화하기 위함.

### 2. 델리게이트 어크로스(Delegate Across)

- **편의 생성자는 같은 클래스 내의 다른 생성자를 호출해야 하며, 최종적으로 지정 생성자로 위임해야 한다.**
- 이는 **코드 중복을 방지하고, 생성자 호출 경로를 명확하게 하기 위함**.

---

## 5️⃣ 2단계 초기화 과정(Two-Phase Initialization)

### 1단계: 저장 속성 초기화

- **현재 클래스에서 선언한 모든 저장 속성이 초기값을 가져야 함**
- `self.init`을 호출할 수 있지만, 상위 클래스 속성에는 접근 불가능
- 이후 `super.init`을 호출하여 부모 클래스의 초기화를 진행

### 2단계: 인스턴스 커스터마이징

- 부모 클래스의 초기화가 완료된 후, **하위 클래스에서 추가 설정 가능**
- 이 단계에서 `self` 속성에 접근할 수 있으며, 메서드 호출 가능

---

## ✨ 세줄 요약

1. **지정 생성자는 모든 저장 속성을 초기화하며, 편의 생성자는 이를 보조하는 역할을 한다.**  
2. **생성자 위임 규칙에는 델리게이트 업(부모 생성자 호출)과 델리게이트 어크로스(같은 클래스 내 호출)가 있다.**  
3. **2단계 초기화 과정은 하위 클래스의 속성을 먼저 초기화한 후, 부모 클래스의 초기화를 진행하는 원칙이다.**  

---

참고 : https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/